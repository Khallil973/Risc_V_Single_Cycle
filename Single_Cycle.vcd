$date
	Sun Jun 02 23:14:57 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module Single_Cycle_Top_Tb $end
$var reg 1 ! clk $end
$var reg 1 " rst $end
$scope module Single_Cycle_Top $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 # SrcB [31:0] $end
$var wire 1 $ ResultSrc_Top $end
$var wire 32 % Result [31:0] $end
$var wire 1 & RegWrite_Top $end
$var wire 32 ' ReadData [31:0] $end
$var wire 32 ( RD_Instrc [31:0] $end
$var wire 32 ) RD2_Top [31:0] $end
$var wire 32 * RD1_Top [31:0] $end
$var wire 32 + PC_Top [31:0] $end
$var wire 32 , PCPlus4 [31:0] $end
$var wire 1 - MemWrite $end
$var wire 32 . Imm_Ext_Top [31:0] $end
$var wire 2 / ImmSrc [1:0] $end
$var wire 3 0 Alu_Control_Top [2:0] $end
$var wire 1 1 ALUSrc_Top $end
$var wire 32 2 ALUResult [31:0] $end
$scope module ALU $end
$var wire 32 3 A_and_B [31:0] $end
$var wire 32 4 A_or_B [31:0] $end
$var wire 1 5 C $end
$var wire 32 6 Result [31:0] $end
$var wire 1 7 V $end
$var wire 32 8 not_B [31:0] $end
$var wire 32 9 sum [31:0] $end
$var wire 32 : slt [31:0] $end
$var wire 32 ; mux_2 [31:0] $end
$var wire 32 < mux_1 [31:0] $end
$var wire 1 = cout $end
$var wire 1 > Z $end
$var wire 1 ? N $end
$var wire 32 @ B [31:0] $end
$var wire 3 A ALUcontrol [2:0] $end
$var wire 32 B A [31:0] $end
$upscope $end
$scope module control $end
$var wire 3 C func3 [2:0] $end
$var wire 7 D func7 [6:0] $end
$var wire 7 E op [6:0] $end
$var wire 1 $ ResultSrc $end
$var wire 1 & RegWrite $end
$var wire 1 - MemWrite $end
$var wire 2 F ImmSrc [1:0] $end
$var wire 1 G Branch $end
$var wire 1 1 ALUSrc $end
$var wire 2 H ALUOp [1:0] $end
$var wire 3 I ALUControl [2:0] $end
$scope module Alu $end
$var wire 3 J func3 [2:0] $end
$var wire 7 K func7 [6:0] $end
$var wire 7 L op5 [6:0] $end
$var wire 2 M concatenation [1:0] $end
$var wire 2 N ALUOp [1:0] $end
$var wire 3 O ALUControl [2:0] $end
$upscope $end
$scope module main $end
$var wire 1 P PCSrc $end
$var wire 1 Q Zero $end
$var wire 7 R op [6:0] $end
$var wire 1 $ ResultSrc $end
$var wire 1 & RegWrite $end
$var wire 1 - MemWrite $end
$var wire 2 S ImmSrc [1:0] $end
$var wire 1 G Branch $end
$var wire 1 1 ALUSrc $end
$var wire 2 T ALUOp [1:0] $end
$upscope $end
$upscope $end
$scope module data $end
$var wire 32 U A [31:0] $end
$var wire 1 - WE $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 V WD [31:0] $end
$var wire 32 W RD [31:0] $end
$upscope $end
$scope module instruction $end
$var wire 1 X clk $end
$var wire 1 " rst $end
$var wire 32 Y RD [31:0] $end
$var wire 32 Z A [31:0] $end
$upscope $end
$scope module mux_DataMem_to_Reg $end
$var wire 32 [ a [31:0] $end
$var wire 32 \ b [31:0] $end
$var wire 1 $ s $end
$var wire 32 ] c [31:0] $end
$upscope $end
$scope module mux_reg_to_ALU $end
$var wire 1 1 s $end
$var wire 32 ^ c [31:0] $end
$var wire 32 _ b [31:0] $end
$var wire 32 ` a [31:0] $end
$upscope $end
$scope module pc $end
$var wire 32 a b [31:0] $end
$var wire 32 b c [31:0] $end
$var wire 32 c a [31:0] $end
$upscope $end
$scope module program $end
$var wire 32 d PC_NEXT [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var reg 32 e PC [31:0] $end
$upscope $end
$scope module register $end
$var wire 5 f A1 [4:0] $end
$var wire 5 g A2 [4:0] $end
$var wire 5 h A3 [4:0] $end
$var wire 32 i WD3 [31:0] $end
$var wire 1 & WE3 $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 j RD2 [31:0] $end
$var wire 32 k RD1 [31:0] $end
$upscope $end
$scope module sign $end
$var wire 1 l ImmSrc $end
$var wire 32 m In [31:0] $end
$var wire 32 n Imm_Ext [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 n
b0 m
0l
b0 k
b0 j
b0 i
b0 h
b0 g
b0 f
b0 e
b100 d
b0 c
b100 b
b100 a
b0 `
b0 _
b0 ^
b0 ]
b0 \
b0 [
b0 Z
b0 Y
zX
b0 W
b0 V
b0 U
b0 T
b0 S
b0 R
zQ
0P
b0 O
b0 N
b0z M
b0 L
bz K
b0 J
b0 I
b0 H
0G
b0 F
b0 E
bz D
b0 C
b0 B
b0 A
b0 @
0?
1>
0=
b0 <
b0 ;
b0 :
b0 9
b11111111111111111111111111111111 8
07
b0 6
05
b0 4
b0 3
b0 2
01
b0 0
b0 /
b0 .
0-
b100 ,
b0 +
b0 *
b0 )
b0 (
b0 '
0&
b0 %
0$
b0 #
0"
0!
$end
#50
1!
#100
b11 0
b11 A
b11 I
b11 O
1&
b10 /
b10 F
b10 S
07
b110 .
b110 _
b110 n
b1z M
b10 H
b10 N
b10 T
0>
0?
b1110 %
b1110 ]
b1110 i
b110 C
b110 J
b110011 E
b110011 L
b110011 R
b100 h
b110 g
b101 f
b1 :
b1110 2
b1110 6
b1110 U
b1110 [
b1110 ;
05
b11111111111111111111111111110101 <
b11111111111111111111111111110101 8
bx '
bx W
bx \
b11000101110001000110011 (
b11000101110001000110011 Y
b11000101110001000110011 m
b11111111111111111111111111111100 9
0=
b10 3
b1110 4
b1010 #
b1010 @
b1010 ^
b110 *
b110 B
b110 k
b1010 )
b1010 V
b1010 `
b1010 j
0!
1"
#150
x7
x5
x>
x?
bx <
bx %
bx ]
bx i
bx 2
bx 6
bx U
bx [
bx ;
bx 8
b0x :
x&
x1
xP
xl
bx 0
bx A
bx I
bx O
bx #
bx @
bx ^
bx 9
x=
bx 3
bx 4
bx .
bx _
bx n
bxz M
x-
x$
xG
bx /
bx F
bx S
bx H
bx N
bx T
bx )
bx V
bx `
bx j
bx *
bx B
bx k
bx C
bx J
bx E
bx L
bx R
bx h
bx g
bx f
bx (
bx Y
bx m
b1000 ,
b1000 b
b1000 d
b100 +
b100 Z
b100 c
b100 e
1!
#200
0!
#250
b1100 ,
b1100 b
b1100 d
b1000 +
b1000 Z
b1000 c
b1000 e
1!
#300
0!
#350
b10000 ,
b10000 b
b10000 d
b1100 +
b1100 Z
b1100 c
b1100 e
1!
#400
0!
